time.plot = plot_dates#2000.25:2018.25 #plot_dates
)
synth.out <- synth(data.prep.obj = dataprep.out,
method = "BFGS")
synth.out$solution.v
gaps<- dataprep.out$Y1plot-(
dataprep.out$Y0plot%*%synth.out$solution.w
) ; gaps
synth.tables <- synth.tab(
dataprep.res = dataprep.out,
synth.res = synth.out)
print(synth.tables)
path.plot(synth.res = synth.out,
dataprep.res = dataprep.out,
Ylab = "Employee Counts in Food Industry",
Xlab = "year",
Ylim =  c(40000,70000), #c(250, 500),
Legend = c("Hennepin County","Synthetic Hennepin country"),
Legend.position = "bottomright",
Main= "Private Food Sector Employee Count Hennepin vs Synthetic"
)
abline(v=2014.25,lty="dotted",lwd=2)
path.plot(synth.res = synth.out,
dataprep.res = dataprep.out,
Ylab = "Employee Counts in Food Industry",
Xlab = "year",
Ylim =  c(40000,70000), #c(250, 500),
Legend = c("Hennepin County","Synthetic Hennepin County"),
Legend.position = "bottomright",
Main= "Private Food Sector Employee Count Hennepin vs Synthetic"
)
dataprep.out<-
dataprep(
foo = merge_data,
predictors = c("month1_emplvl", "month2_emplvl", 'month3_emplvl',
'POPESTIMATE2010', 'POPESTIMATE2011', 'POPESTIMATE2012', 'POPESTIMATE2014',
'POPESTIMATE2016', 'BIRTHS2010', 'BIRTHS2012', 'BIRTHS2014',
'BIRTHS2016', 'DEATHS2010', 'DEATHS2012', 'DEATHS2014', 'DEATHS2016'),
predictors.op = "mean",
dependent =   'qrtly_emp_count',#'avg_wkly_wage',
unit.variable = "area_fips",
time.variable = "year2",
# special.predictors = list(
#   list("Y", 1991, "mean"),
#   list("Y", 1985, "mean"),
#   list("Y", 1980, "mean")
# ),
treatment.identifier = 27053,
controls.identifier = no_sig_chg_counties,#head(control_list, 200),#c(13245, 13215, 13179, 11001, 8041, 6077),
time.predictors.prior = prior_dates,#dates,#c(2011.25:2018.25),
time.optimize.ssr = opt_dates,#dates, #c(2010.25:2018.25),
#unit.names.variable = "area_title",
time.plot = plot_dates#2000.25:2018.25 #plot_dates
)
dataprep.out<-
dataprep(
foo = merge_data,
predictors = c("month1_emplvl", "month2_emplvl", 'month3_emplvl',
'POPESTIMATE2010', 'POPESTIMATE2012', 'POPESTIMATE2014',
'POPESTIMATE2016', 'BIRTHS2010', 'BIRTHS2012', 'BIRTHS2014',
'BIRTHS2016', 'DEATHS2010', 'DEATHS2012', 'DEATHS2014', 'DEATHS2016'),
predictors.op = "mean",
dependent =   'qrtly_emp_count',#'avg_wkly_wage',
unit.variable = "area_fips",
time.variable = "year2",
# special.predictors = list(
#   list("Y", 1991, "mean"),
#   list("Y", 1985, "mean"),
#   list("Y", 1980, "mean")
# ),
treatment.identifier = 27053,
controls.identifier = no_sig_chg_counties,#head(control_list, 200),#c(13245, 13215, 13179, 11001, 8041, 6077),
time.predictors.prior = prior_dates,#dates,#c(2011.25:2018.25),
time.optimize.ssr = opt_dates,#dates, #c(2010.25:2018.25),
#unit.names.variable = "area_title",
time.plot = plot_dates#2000.25:2018.25 #plot_dates
)
abline(v=2014.25,lty="dotted",lwd=2)
df  <- read.csv('Dataset_spine.csv', col.names = c('pelvic_incidence', 'pelvic_tilt', 'lumbar_lordosis_angle', 'sacral_slope', 'pelvic_radius', 'degree_spondylolisthesis', 'pelvic_slope', 'Direct_tilt', 'thoracic_slope', 'cervical_tilt', 'sacrum_angle', 'scoliosis_slope', 'classification', ' '))
df$classification = ifelse(df$classification == "Abnormal", 0, 1) #making classification numeric
df$X. <- NULL #dropping the column with variable descriptions in it
data = scale(df[, 1:12]) #scaling all except classification variable
data = data.frame(data)
data$classification = df$classification #add classification back into scaled dataframe
set.seed(12)
rand_df = data.frame(matrix(rnorm(500*nrow(data)), nrow = nrow(data), ncol = 500))
data = cbind(data, rand_df)
data$rand_int = runif(n=nrow(data), min = 0, max = 1) #random values from uniform distribution
data2 = data[order(data$rand_int),] #reorder dataframe by random value
data2$group = seq(from = 1, to=5, by=1)
attach(data2)
data2$pred_svm = 0
for (grp in 1:5){
train = data2[data2$group != grp, ]
test = data2[data2$group == grp,]
svm <- svm(classification ~ .,
data=train)
cv_svm_pred = predict(svm, test, type = 'response')
data2$pred_svm[data2$group == grp] = cv_svm_pred
}
cv_svm_cfr_w500 = ModelMetrics::confusionMatrix( predicted = data2$pred_svm, actual = data2$classification)
cv_svm_cfr_w500 #with provided random noise
#accuracy score for Cross Validated RandomForest with Provided Random Noise
acc_cv_svm_w500 = (cv_svm_cfr_w500[1,1] + cv_svm_cfr_w500[2,2])/nrow(data2)
acc_cv_svm_w500
setwd("C:/Users/Michael Streyle/Desktop/Senior Project") #change this when i switch computers
set.seed(12)
df  <- read.csv('Dataset_spine.csv', col.names = c('pelvic_incidence', 'pelvic_tilt', 'lumbar_lordosis_angle', 'sacral_slope', 'pelvic_radius', 'degree_spondylolisthesis', 'pelvic_slope', 'Direct_tilt', 'thoracic_slope', 'cervical_tilt', 'sacrum_angle', 'scoliosis_slope', 'classification', ' '))
df$classification = ifelse(df$classification == "Abnormal", 0, 1) #making classification numeric
df$X. <- NULL #dropping the column with variable descriptions in it
data = scale(df[, 1:12]) #scaling all except classification variable
data = data.frame(data)
data$classification = df$classification #add classification back into scaled dataframe
set.seed(12)
rand_df = data.frame(matrix(rnorm(500*nrow(data)), nrow = nrow(data), ncol = 500))
data = cbind(data, rand_df)
data$rand_int = runif(n=nrow(data), min = 0, max = 1) #random values from uniform distribution
data2 = data[order(data$rand_int),] #reorder dataframe by random value
data2$group = seq(from = 1, to=5, by=1)
attach(data2)
data2$pred_svm = 0
for (grp in 1:5){
train = data2[data2$group != grp, ]
test = data2[data2$group == grp,]
svm <- svm(classification ~ .,
data=train)
cv_svm_pred = predict(svm, test, type = 'response')
data2$pred_svm[data2$group == grp] = cv_svm_pred
}
cv_svm_cfr_w500 = ModelMetrics::confusionMatrix( predicted = data2$pred_svm, actual = data2$classification)
cv_svm_cfr_w500 #with provided random noise
#accuracy score for Cross Validated RandomForest with Provided Random Noise
acc_cv_svm_w500 = (cv_svm_cfr_w500[1,1] + cv_svm_cfr_w500[2,2])/nrow(data2)
acc_cv_svm_w500
df  <- read.csv('Dataset_spine.csv', col.names = c('pelvic_incidence', 'pelvic_tilt', 'lumbar_lordosis_angle', 'sacral_slope', 'pelvic_radius', 'degree_spondylolisthesis', 'pelvic_slope', 'Direct_tilt', 'thoracic_slope', 'cervical_tilt', 'sacrum_angle', 'scoliosis_slope', 'classification', ' '))
df$classification = ifelse(df$classification == "Abnormal", 0, 1) #making classification numeric
df$X. <- NULL #dropping the column with variable descriptions in it
data = scale(df[, 1:12]) #scaling all except classification variable
data = data.frame(data)
data$classification = df$classification #add classification back into scaled dataframe
set.seed(12)
rand_df = data.frame(matrix(rnorm(1000*nrow(data)), nrow = nrow(data), ncol = 1000))
data = cbind(data, rand_df)
data$rand_int = runif(n=nrow(data), min = 0, max = 1) #random values from uniform distribution
data2 = data[order(data$rand_int),] #reorder dataframe by random value
data2$group = seq(from = 1, to=5, by=1)
attach(data2)
data2$pred_svm = 0
for (grp in 1:5){
train = data2[data2$group != grp, ]
test = data2[data2$group == grp,]
svm <- svm(classification ~ .,
data=train)
cv_svm_pred = predict(svm, test, type = 'response')
data2$pred_svm[data2$group == grp] = cv_svm_pred
}
cv_svm_cfr_w1000 = ModelMetrics::confusionMatrix( predicted = data2$pred_svm, actual = data2$classification)
cv_svm_cfr_w1000 #with provided random noise
#accuracy score for Cross Validated RandomForest with Provided Random Noise
acc_cv_svm_w1000 = (cv_svm_cfr_w1000[1,1] + cv_svm_cfr_w1000[2,2])/nrow(data2)
acc_cv_svm_w1000
df  <- read.csv('Dataset_spine.csv', col.names = c('pelvic_incidence', 'pelvic_tilt', 'lumbar_lordosis_angle', 'sacral_slope', 'pelvic_radius', 'degree_spondylolisthesis', 'pelvic_slope', 'Direct_tilt', 'thoracic_slope', 'cervical_tilt', 'sacrum_angle', 'scoliosis_slope', 'classification', ' '))
df$classification = ifelse(df$classification == "Abnormal", 0, 1) #making classification numeric
df$X. <- NULL #dropping the column with variable descriptions in it
data = scale(df[, 1:12]) #scaling all except classification variable
data = data.frame(data)
data$classification = df$classification #add classification back into scaled dataframe
set.seed(12)
rand_df = data.frame(matrix(rnorm(1000*nrow(data)), nrow = nrow(data), ncol = 1000))
data = cbind(data, rand_df)
data$rand_int = runif(n=nrow(data), min = 0, max = 1) #random values from uniform distribution
data2 = data[order(data$rand_int),] #reorder dataframe by random value
data2$group = seq(from = 1, to=5, by=1)
attach(data2)
data2$pred_svm = 0
for (grp in 1:5){
train = data2[data2$group != grp, ]
test = data2[data2$group == grp,]
svm <- svm(classification ~ .,
data=train)
cv_svm_pred = predict(svm, test, type = 'response')
data2$pred_svm[data2$group == grp] = cv_svm_pred
}
cv_svm_cfr_w1000 = ModelMetrics::confusionMatrix( predicted = data2$pred_svm, actual = data2$classification)
cv_svm_cfr_w1000 #with provided random noise
#accuracy score for Cross Validated RandomForest with Provided Random Noise
acc_cv_svm_w1000 = (cv_svm_cfr_w1000[1,1] + cv_svm_cfr_w1000[2,2])/nrow(data2)
acc_cv_svm_w1000
setwd("C:/Users/Michael Streyle/Desktop/Senior Project") #change this when i switch computers
set.seed(12)
df  <- read.csv('Dataset_spine.csv', col.names = c('pelvic_incidence', 'pelvic_tilt', 'lumbar_lordosis_angle', 'sacral_slope', 'pelvic_radius', 'degree_spondylolisthesis', 'pelvic_slope', 'Direct_tilt', 'thoracic_slope', 'cervical_tilt', 'sacrum_angle', 'scoliosis_slope', 'classification', ' '))
df$classification = ifelse(df$classification == "Abnormal", 0, 1) #making classification numeric
df$X. <- NULL #dropping the column with variable descriptions in it
data = scale(df[, 1:12]) #scaling all except classification variable
data = data.frame(data)
data$classification = df$classification #add classification back into scaled dataframe
set.seed(12)
rand_df = data.frame(matrix(rnorm(1000*nrow(data)), nrow = nrow(data), ncol = 1000))
data = cbind(data, rand_df)
data$rand_int = runif(n=nrow(data), min = 0, max = 1) #random values from uniform distribution
data2 = data[order(data$rand_int),] #reorder dataframe by random value
data2$group = seq(from = 1, to=5, by=1)
attach(data2)
data2$pred_svm = 0
for (grp in 1:5){
train = data2[data2$group != grp, ]
test = data2[data2$group == grp,]
svm <- svm(classification ~ .,
data=train)
cv_svm_pred = predict(svm, test, type = 'response')
data2$pred_svm[data2$group == grp] = cv_svm_pred
}
cv_svm_cfr_w1000 = ModelMetrics::confusionMatrix( predicted = data2$pred_svm, actual = data2$classification)
cv_svm_cfr_w1000 #with provided random noise
#accuracy score for Cross Validated RandomForest with Provided Random Noise
acc_cv_svm_w1000 = (cv_svm_cfr_w1000[1,1] + cv_svm_cfr_w1000[2,2])/nrow(data2)
acc_cv_svm_w1000
df  <- read.csv('Dataset_spine.csv', col.names = c('pelvic_incidence', 'pelvic_tilt', 'lumbar_lordosis_angle', 'sacral_slope', 'pelvic_radius', 'degree_spondylolisthesis', 'pelvic_slope', 'Direct_tilt', 'thoracic_slope', 'cervical_tilt', 'sacrum_angle', 'scoliosis_slope', 'classification', ' '))
df$classification = ifelse(df$classification == "Abnormal", 0, 1) #making classification numeric
df$X. <- NULL #dropping the column with variable descriptions in it
data = scale(df[, 1:12]) #scaling all except classification variable
data = data.frame(data)
data$classification = df$classification #add classification back into scaled dataframe
set.seed(12)
rand_df = data.frame(matrix(rnorm(500*nrow(data)), nrow = nrow(data), ncol = 500))
data = cbind(data, rand_df)
data$rand_int = runif(n=nrow(data), min = 0, max = 1) #random values from uniform distribution
data2 = data[order(data$rand_int),] #reorder dataframe by random value
data2$group = seq(from = 1, to=5, by=1)
attach(data2)
data2$pred_svm = 0
for (grp in 1:5){
train = data2[data2$group != grp, ]
test = data2[data2$group == grp,]
svm <- svm(classification ~ .  - rand_int - group - pred_svm,
data=train)
cv_svm_pred = predict(svm, test, type = 'response')
data2$pred_svm[data2$group == grp] = cv_svm_pred
}
cv_svm_cfr_w500 = ModelMetrics::confusionMatrix( predicted = data2$pred_svm, actual = data2$classification)
cv_svm_cfr_w500 #with provided random noise
#accuracy score for Cross Validated RandomForest with Provided Random Noise
acc_cv_svm_w500 = (cv_svm_cfr_w500[1,1] + cv_svm_cfr_w500[2,2])/nrow(data2)
acc_cv_svm_w500
df  <- read.csv('Dataset_spine.csv', col.names = c('pelvic_incidence', 'pelvic_tilt', 'lumbar_lordosis_angle', 'sacral_slope', 'pelvic_radius', 'degree_spondylolisthesis', 'pelvic_slope', 'Direct_tilt', 'thoracic_slope', 'cervical_tilt', 'sacrum_angle', 'scoliosis_slope', 'classification', ' '))
df$classification = ifelse(df$classification == "Abnormal", 0, 1) #making classification numeric
df$X. <- NULL #dropping the column with variable descriptions in it
data = scale(df[, 1:12]) #scaling all except classification variable
data = data.frame(data)
data$classification = df$classification #add classification back into scaled dataframe
set.seed(12)
rand_df = data.frame(matrix(rnorm(1000*nrow(data)), nrow = nrow(data), ncol = 1000))
data = cbind(data, rand_df)
data$rand_int = runif(n=nrow(data), min = 0, max = 1) #random values from uniform distribution
data2 = data[order(data$rand_int),] #reorder dataframe by random value
data2$group = seq(from = 1, to=5, by=1)
attach(data2)
data2$pred_svm = 0
for (grp in 1:5){
train = data2[data2$group != grp, ]
test = data2[data2$group == grp,]
svm <- svm(classification ~ .  - rand_int - group - pred_svm,
data=train)
cv_svm_pred = predict(svm, test, type = 'response')
data2$pred_svm[data2$group == grp] = cv_svm_pred
}
cv_svm_cfr_w1000 = ModelMetrics::confusionMatrix( predicted = data2$pred_svm, actual = data2$classification)
cv_svm_cfr_w1000 #with provided random noise
#accuracy score for Cross Validated RandomForest with Provided Random Noise
acc_cv_svm_w1000 = (cv_svm_cfr_w1000[1,1] + cv_svm_cfr_w1000[2,2])/nrow(data2)
acc_cv_svm_w1000
cv_svm_cfr_w500 #with provided random noise
cv_svm_cfr_w1000 #with provided random noise
df  <- read.csv('Dataset_spine.csv', col.names = c('pelvic_incidence', 'pelvic_tilt', 'lumbar_lordosis_angle', 'sacral_slope', 'pelvic_radius', 'degree_spondylolisthesis', 'pelvic_slope', 'Direct_tilt', 'thoracic_slope', 'cervical_tilt', 'sacrum_angle', 'scoliosis_slope', 'classification', ' '))
df$classification = ifelse(df$classification == "Abnormal", 0, 1) #making classification numeric
df$X. <- NULL #dropping the column with variable descriptions in it
data = scale(df[, 1:12]) #scaling all except classification variable
data = data.frame(data)
data$classification = df$classification #add classification back into scaled dataframe
rand_df = data.frame(matrix(rnorm(500*nrow(data)), nrow = nrow(data), ncol = 500))
data = cbind(data, rand_df)
data$rand_int = runif(n=nrow(data), min = 0, max = 1) #random values from uniform distribution
data2 = data[order(data$rand_int),] #reorder dataframe by random value
data2$group = seq(from = 1, to=5, by=1)
attach(data2)
data2$pred_cv = 0
for (grp in 1:5){
train = data2[data2$group != grp, ]
test = data2[data2$group == grp,]
cv_lr <- glm(classification ~ . - rand_int - group - pred_cv,
data=train, family=binomial(link="logit"))
cv_lr_pred = predict(cv_lr, test, type = 'response')
data2$pred_cv[data2$group == grp] = cv_lr_pred
}
cv_lr_cfr_w500 = ModelMetrics::confusionMatrix( predicted = data2$pred_cv, actual = data2$classification)
cv_lr_cfr_w500 #with provided random noise
#accuracy score for Cross Validated RandomForest with Provided Random Noise
acc_cv_lr_w500 = (cv_lr_cfr_w500[1,1] + cv_lr_cfr_w500[2,2])/nrow(data2)
acc_cv_lr_w500
summary(cv_lr)
#PCA for 1000 random variables
myvars <- names(data2) %in% c("classification", "rand_int", "pred_cv", "group") #remove classificaiton
newdata = data2[!myvars]
prin_comp = prcomp(newdata, scale.= T)
names(prin_comp)
prin_comp$rotation[1:5,1:4]
biplot(prin_comp, scale = 0)
std_dev <- prin_comp$sdev
pr_var <- std_dev^2
pr_var[1:10]
prop_varex <- pr_var/sum(pr_var)
prop_varex[1:20]
plot(prop_varex, xlab = "Principal Component",
ylab = "Proportion of Variance Explained",
type = "b", main='Variance Explained 500')
plot(cumsum(prop_varex), xlab = "Principal Component",
ylab = "Cumulative Proportion of Variance Explained",
type = "b", main= "Cumulative Variance Explained 500")
tuned_parameters <- tune.svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, gamma = 10^(-5:-1), cost = 10^(-3:1))
setwd("C:/Users/Michael Streyle/Desktop/Senior Project") #change this when i switch computers
set.seed(12)
data1  <- read.csv('Dataset_spine.csv', col.names = c('pelvic_incidence', 'pelvic_tilt', 'lumbar_lordosis_angle', 'sacral_slope', 'pelvic_radius', 'degree_spondylolisthesis', 'pelvic_slope', 'Direct_tilt', 'thoracic_slope', 'cervical_tilt', 'sacrum_angle', 'scoliosis_slope', 'classification', ' '))
data1$X. <- NULL #dropping the column with variable descriptions in it
data = scale(data1[, 1:12]) #scaling all except classification variable
data = data.frame(data)
data$classification = data1$classification #add classification back into scaled dataframe
data$class = ifelse(data$classification == "Abnormal", 0, 1) #making classification numeric
library(e1071) #SVM
library(randomForest)
library(caret) #for confusion matrices
attach(data)
tuned_parameters <- tune.svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, gamma = 10^(-5:-1), cost = 10^(-3:1))
smp_size <- floor(0.8 * nrow(data))
set.seed(12)
train_ind <- sample(seq_len(nrow(data)), size = smp_size)
svm_train <- data[train_ind, ]
svm_test <- data[-train_ind, ]
tuned_parameters <- tune.svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, gamma = 10^(-5:-1), cost = 10^(-3:1))
summary(tuned_parameters )
tune_model_svm <- svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, gamma = 0.01, cost= 10)
pred2 <- predict(tune_model_svm, svm_test, probability = T)
pred2 <- predict(tune_model_svm, svm_test)
svm_test$svm_pred2 = pred2
tune_svm_cf = confusionMatrix(data = svm_test$svm_pred2, reference = svm_test$classification)
tune_svm_cf
svm_cf
#make train and test set
smp_size <- floor(0.8 * nrow(data))
set.seed(12)
train_ind <- sample(seq_len(nrow(data)), size = smp_size)
svm_train <- data[train_ind, ]
svm_test <- data[-train_ind, ]
#Fit a model. The function syntax is very similar to lm function
model_svm <- svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, probability = T)
sum1 = summary(model_svm)
#Use the predictions on the data
pred <- predict(model_svm, svm_test, probability = T)
svm_test$svm_pred = pred
svm_cf = confusionMatrix(data = svm_test$svm_pred, reference = svm_test$classification)
svm_cf
#accuracy score is now in the confusion matrix output
#tune initial model
tuned_parameters <- tune.svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, gamma = 10^(-5:-1), cost = 10^(-3:1))
summary(tuned_parameters )
tune_model_svm <- svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, gamma = 0.01, cost= 10)
pred2 <- predict(tune_model_svm, svm_test)
svm_test$svm_pred2 = pred2
tune_svm_cf = confusionMatrix(data = svm_test$svm_pred2, reference = svm_test$classification)
tune_svm_cf
svm_cf
tune_svm_cf
summary(tuned_parameters )
tune_model_svm <- svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, gamma = 0.1, cost= 1)
pred2 <- predict(tune_model_svm, svm_test)
svm_test$svm_pred2 = pred2
tune_svm_cf = confusionMatrix(data = svm_test$svm_pred2, reference = svm_test$classification)
tune_svm_cf
tune_model_svm <- svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, gamma = 0.01, cost= 10)
pred2 <- predict(tune_model_svm, svm_test)
svm_test$svm_pred2 = pred2
tune_svm_cf = confusionMatrix(data = svm_test$svm_pred2, reference = svm_test$classification)
tune_svm_cf
tune_model_svm <- svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, gamma = 0.01, cost= 100)
pred2 <- predict(tune_model_svm, svm_test)
svm_test$svm_pred2 = pred2
tune_svm_cf = confusionMatrix(data = svm_test$svm_pred2, reference = svm_test$classification)
tune_svm_cf
tune_model_svm <- svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, gamma = 0.01, cost= 5)
pred2 <- predict(tune_model_svm, svm_test)
svm_test$svm_pred2 = pred2
tune_svm_cf = confusionMatrix(data = svm_test$svm_pred2, reference = svm_test$classification)
tune_svm_cf
tune_model_svm <- svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, gamma = 0.5, cost= 5)
pred2 <- predict(tune_model_svm, svm_test)
svm_test$svm_pred2 = pred2
tune_svm_cf = confusionMatrix(data = svm_test$svm_pred2, reference = svm_test$classification)
tune_svm_cf
tune_model_svm <- svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, gamma = 0.1, cost= 5)
pred2 <- predict(tune_model_svm, svm_test)
svm_test$svm_pred2 = pred2
tune_svm_cf = confusionMatrix(data = svm_test$svm_pred2, reference = svm_test$classification)
tune_svm_cf
tune_model_svm <- svm(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = svm_train, gamma = 0.1, cost= 1)
pred2 <- predict(tune_model_svm, svm_test)
svm_test$svm_pred2 = pred2
tune_svm_cf = confusionMatrix(data = svm_test$svm_pred2, reference = svm_test$classification)
tune_svm_cf
setwd("C:/Users/Michael Streyle/Desktop/Senior Project") #change this when i switch computers
data1  <- read.csv('Dataset_spine.csv', col.names = c('pelvic_incidence', 'pelvic_tilt', 'lumbar_lordosis_angle', 'sacral_slope', 'pelvic_radius', 'degree_spondylolisthesis', 'pelvic_slope', 'Direct_tilt', 'thoracic_slope', 'cervical_tilt', 'sacrum_angle', 'scoliosis_slope', 'classification', ' '))
data1$X. <- NULL #dropping the column with variable descriptions in it
data = scale(data1[, 1:12]) #scaling all except classification variable
data = data.frame(data)
data$classification = data1$classification #add classification back into scaled dataframe
data$class = ifelse(data$classification == "Abnormal", 0, 1) #making classification numeric
library(e1071) #SVM
library(randomForest)
library(caret) #for confusion matrices
attach(data)
smp_size <- floor(0.8 * nrow(data))
set.seed(12)
train_ind <- sample(seq_len(nrow(data)), size = smp_size)
rf_train <- data[train_ind, ]
rf_test <- data[-train_ind, ]
random_forest = randomForest(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = rf_train)
random_forest
plot(random_forest)
importance(random_forest)
varImpPlot(random_forest,type=2)
pred = predict(random_forest, rf_test)
rf_test$rf_pred = pred
rf_cf = confusionMatrix(rf_test$classification, rf_test$rf_pred)
rf_cf
bestmtry <- tuneRF(classification ~ pelvic_tilt + pelvic_incidence + lumbar_lordosis_angle + sacral_slope + pelvic_radius + degree_spondylolisthesis, data = rf_train, stepFactor=1.5, improve=1e-5, ntree=500)
bestmtry <- tuneRF(x = c(pelvic_tilt,pelvic_incidence, lumbar_lordosis_angle,sacral_slope,pelvic_radius,degree_spondylolisthesis), y = classification, stepFactor=1.5, improve=1e-5, ntree=500)
install.packages("TeX")
library("tinytex", lib.loc="~/R/win-library/3.5")
install.packages("latexpdf")
tinytex::latexmk(spine_tree.tex)
tinytex::latexmk('C:\Users\Michael Streyle\Desktop\Senior Project\GUIDE\spine_tree.tex')
tinytex::latexmk("C:\Users\Michael Streyle\Desktop\Senior Project\GUIDE\spine_tree.tex")
setwd("C:/Users/Michael Streyle/Desktop/Senior Project/GUIDE")
tinytex::latexmk(spine_tree.tex)
tinytex::latexmk("spine_tree.tex")
library("latexpdf", lib.loc="~/R/win-library/3.5")
tinytex::latexmk("spine_tree.tex")
install.packages("pdfLaTeX")
df  <- read.csv('Dataset_spine.csv', col.names = c('pelvic_incidence', 'pelvic_tilt', 'lumbar_lordosis_angle', 'sacral_slope', 'pelvic_radius', 'degree_spondylolisthesis', 'pelvic_slope', 'Direct_tilt', 'thoracic_slope', 'cervical_tilt', 'sacrum_angle', 'scoliosis_slope', 'classification', ' '))
df$classification = ifelse(df$classification == "Abnormal", 0, 1) #making classification numeric
df$X. <- NULL #dropping the column with variable descriptions in it
data = scale(df[, 1:12]) #scaling all except classification variable
data = data.frame(data)
data$classification = df$classification #add classification back into scaled dataframe
rand_df = data.frame(matrix(rnorm(100*nrow(data)), nrow = nrow(data), ncol = 100))
data = cbind(data, rand_df)
data$rand_int = runif(n=nrow(data), min = 0, max = 1) #random values from uniform distribution
data2 = data[order(data$rand_int),] #reorder dataframe by random value
data2$group = seq(from = 1, to=5, by=1)
attach(data2)
data2$pred_cv = 0
for (grp in 1:5){
train = data2[data2$group != grp, ]
test = data2[data2$group == grp,]
cv_lr <- glm(classification ~ .- rand_int - group - pred_cv,
data=train, family=binomial(link="logit"))
cv_lr_pred = predict(cv_lr, test, type = 'response')
data2$pred_cv[data2$group == grp] = cv_lr_pred
}
summary(cv_lr)
cv_lr_cfr_w100 = ModelMetrics::confusionMatrix( predicted = data2$pred_cv, actual = data2$classification)
cv_lr_cfr_w100 #with provided random noise
#accuracy score for Cross Validated RandomForest with Provided Random Noise
acc_cv_lr_w100 = (cv_lr_cfr_w100[1,1] + cv_lr_cfr_w100[2,2])/nrow(data2)
acc_cv_lr_w100
#PCA for 100 random variables
myvars <- names(data2) %in% c("classification", "rand_int", "pred_cv", "group") #remove classificaiton
newdata = data2[!myvars]
prin_comp = prcomp(newdata, scale.= T)
names(prin_comp)
prin_comp$rotation[1:5,1:4]
biplot(prin_comp, scale = 0)
std_dev <- prin_comp$sdev
pr_var <- std_dev^2
pr_var[1:10]
prop_varex <- pr_var/sum(pr_var)
prop_varex[1:20]
plot(prop_varex, xlab = "Principal Component",
ylab = "Proportion of Variance Explained",
type = "b", main='Variance Explained 100')
plot(cumsum(prop_varex), xlab = "Principal Component",
ylab = "Cumulative Proportion of Variance Explained",
type = "b", main= "Cumulative Variance Explained 100")
View(data2)
names(data2)
cors = cor(data2[,14:113])
cors[1:5,1:5]
unicor = unique(cors)
unicor
typeof(unicor)
dim(unicor)
vec_dim = as.factor(cors)
dim(vec_dim)
hist(vec_dim)
typeof(vec_dim)
length(vec_dim)
vec_dim
vec_dim2 = as.array(vec_dim)
hist(vec_dim2)
vec_dim[1]
vec_dim[2]
vec_dim = as.vector(cors)
hist(vec_dim)
summary(tuned_parameters )
